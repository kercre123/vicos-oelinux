#!/bin/bash
#
# fault-code-handler
#
# Copyright 2018    Anki, Inc.
# Accepts fault code string on stdin and invokes associated actions, including:
#
# - stops anki-robot.target (victor.target)
# - display fault code on face
# - (optional) restart anki-robot.target
#

set -u

: ${ON_FAULT_RESTART:=0}
: ${TIMEOUT_SIGTERM_SEC:=3}
: ${TIMEOUT_RESTART_SEC:=5}

# enable VERBOSE for debugging
: ${VERBOSE:=0}

PROGRESS_FILE="/run/fault_code.pending"
TRACE_PATH="/data/ankitrace/faults"
LOGGER="/bin/logger -t fault-code-handler"

function log () {
  ${LOGGER} -p user.info -- "$*"
}

function loge () {
  ${LOGGER} -p user.err -- "$*"
}

function logv () {
  if [ $VERBOSE -eq 1 ]; then
    ${LOGGER} -p user.debug -- "$*"
  fi
}

logv "fault-code-handler: start"

# Read up to 7 chars (max code is UINT16_MAX, newline, null) from stdin with a 1 sec timeout
# If run from systemd, stdin will be our fault_code FIFO socket
read -r -n 7 -t 1 FAULT_CODE

if [ $? -ne 0 ]; then
    # read error
    logv "error: read failed"
    exit -1
fi

if [ -z ${FAULT_CODE+x} ]; then
    logv "error: empty or invalid fault code"
    exit -1
fi

# remove anything that is not a number
FAULT_CODE=${FAULT_CODE//[^0-9]/}

# Ignore zero
# Nobody should be writing 0 to the fifo, so it probably means
# the fifo was closed after processes were shutdown
if [ $FAULT_CODE -eq 0 ]; then
  exit 0
fi

if [ -f $PROGRESS_FILE ]; then
    logv "$(basename $0) in progress"
    exit 0
fi

echo $FAULT_CODE > $PROGRESS_FILE

if [ -f /usr/bin/ankitrace ]; then
   /usr/bin/ankitrace -r $TRACE_PATH/$FAULT_CODE
fi

# Log source, event, i1 to DAS
/anki/bin/vic-log-event fault-code-handler robot.fault_code '' '' '' '' ${FAULT_CODE}

logv "FAULT_CODE=$FAULT_CODE"

STOP_DASMGR_ONLY=0
KILL_CAMERA_AFTER_STOPPING_ROBOT=0

# handle error-code specific actions
case $FAULT_CODE in
70[0-2])
    # These codes indicate shutdown modes that require vic-robot to stay alive
    # in order to tell syscon to shutdown. In theory you can try to kill all of
    # the other processes, but there may not be enough time since power could
    # be cut by syscon at any moment so instead we just kill vic-dasmgr to make
    # sure the power_off DAS message is recorded and backed up.
    logv "Shutting down. Stopping vic-dasmgr only."
    STOP_DASMGR_ONLY=1
    ON_FAULT_RESTART=0
    ;;
98[0-1])
    # These codes indicate issues with the camera
    # These issues are typically caused by mm-anki-camera hanging
    # when we try to stop the camera stream on vic-engine
    # stop. We have to manually kill it and start it again.
    KILL_CAMERA_AFTER_STOPPING_ROBOT=1
    ;;
*)
    ;;
esac

# Get a list of services that belong to anki-robot.target
ANKI_SERVICES=( $(systemctl show --plain -p ConsistsOf anki-robot.target | cut -d= -f2-) )

function wait_until_services_stopped() {
    RUNNING_PROCS=()

    for i in $(seq 1 ${TIMEOUT_SIGTERM_SEC}); do
        RUNNING_PROCS=()
        for SRV in ${ANKI_SERVICES[@]}; do
            status="`systemctl is-active ${SRV}`"
            log "Service ${SRV} is ${status}"
            case "${status}" in
            activating|active|deactivating)
                RUNNING_PROCS+=($SRV)
                ;;
            *)
                ;;
            esac
        done

        if [ ${#RUNNING_PROCS[*]} -gt 0 ]; then
            log "Waiting for ${RUNNING_PROCS[@]}"
            sleep 1
        else
            break
        fi
    done

    #
    # If services do not stop in response to SIGTERM,
    # force a crash for diagnostics.
    #
    if [ ${#RUNNING_PROCS[*]} -gt 0 ]; then
        log "systemctl kill -s SIGILL ${RUNNING_PROCS[@]}"
        systemctl kill -s SIGILL ${RUNNING_PROCS[@]}
        sleep 1
    fi
}

#
# Terminate services with SIGTERM instead of "systemctl stop"
# to avoid waiting for individual services to stop.
# Once we have signalled each service, poll status until they stop.
#
if [ $STOP_DASMGR_ONLY -eq 1 ]; then
    ANKI_SERVICES=( "vic-dasmgr" )
    log "systemctl kill -s SIGTERM vic-dasmgr"
    systemctl kill -s SIGTERM vic-dasmgr
    wait_until_services_stopped
else
    log "systemctl kill -s SIGTERM ${ANKI_SERVICES[@]}"
    systemctl kill -s SIGTERM ${ANKI_SERVICES[@]}
    wait_until_services_stopped

    # display error code
    logv "display fault code"
    [ -x /anki/bin/vic-faultCodeDisplay ] && /anki/bin/vic-faultCodeDisplay "${FAULT_CODE}"
fi

if [ $KILL_CAMERA_AFTER_STOPPING_ROBOT -eq 1 ]; then
  logv "kill and restart mm-anki-camera"
  systemctl kill -s 9 mm-anki-camera
  systemctl start mm-anki-camera
fi

if [ $ON_FAULT_RESTART -eq 1 ]; then
    if [ $TIMEOUT_RESTART_SEC -gt 0 ]; then
        logv "display fault code for $TIMEOUT_RESTART_SEC"
        sleep $TIMEOUT_RESTART_SEC
    fi

    # restart processes
    logv "restart anki-robot.target"
    systemctl restart anki-robot.target
fi

log "fault-code-handler done"
rm -f $PROGRESS_FILE
